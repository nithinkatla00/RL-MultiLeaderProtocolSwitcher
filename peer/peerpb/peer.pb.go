// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: peer/peerpb/peer.proto

package peerpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Algorithm int32

const (
	Algorithm_PBFT                Algorithm = 0
	Algorithm_SBFT                Algorithm = 1
	Algorithm_Zyzzyva             Algorithm = 2
	Algorithm_EzBFT               Algorithm = 3
	Algorithm_Hybster             Algorithm = 4
	Algorithm_Destiny             Algorithm = 5
	Algorithm_Dester              Algorithm = 6
	Algorithm_LinHybster          Algorithm = 7
	Algorithm_SBFTSlow            Algorithm = 8
	Algorithm_Hotstuff            Algorithm = 9
	Algorithm_Broadcast           Algorithm = 10
	Algorithm_Prime               Algorithm = 11
	Algorithm_PreDestiny          Algorithm = 12
	Algorithm_MinBFT              Algorithm = 13
	Algorithm_DuoBFT              Algorithm = 14
	Algorithm_MinBFTSig           Algorithm = 15
	Algorithm_SBFTx               Algorithm = 16
	Algorithm_Hybsterx            Algorithm = 17
	Algorithm_ChainHotstuff       Algorithm = 18
	Algorithm_RCC                 Algorithm = 19
	Algorithm_MirBFT              Algorithm = 20
	Algorithm_Dispel              Algorithm = 21
	Algorithm_DQPBFT              Algorithm = 22
	Algorithm_DQSBFTSlow          Algorithm = 23
	Algorithm_ChainDuoBFT         Algorithm = 24
	Algorithm_MultiChainDuoBFT    Algorithm = 25
	Algorithm_MultiChainDuoBFTRCC Algorithm = 26
)

var Algorithm_name = map[int32]string{
	0:  "PBFT",
	1:  "SBFT",
	2:  "Zyzzyva",
	3:  "EzBFT",
	4:  "Hybster",
	5:  "Destiny",
	6:  "Dester",
	7:  "LinHybster",
	8:  "SBFTSlow",
	9:  "Hotstuff",
	10: "Broadcast",
	11: "Prime",
	12: "PreDestiny",
	13: "MinBFT",
	14: "DuoBFT",
	15: "MinBFTSig",
	16: "SBFTx",
	17: "Hybsterx",
	18: "ChainHotstuff",
	19: "RCC",
	20: "MirBFT",
	21: "Dispel",
	22: "DQPBFT",
	23: "DQSBFTSlow",
	24: "ChainDuoBFT",
	25: "MultiChainDuoBFT",
	26: "MultiChainDuoBFTRCC",
}

var Algorithm_value = map[string]int32{
	"PBFT":                0,
	"SBFT":                1,
	"Zyzzyva":             2,
	"EzBFT":               3,
	"Hybster":             4,
	"Destiny":             5,
	"Dester":              6,
	"LinHybster":          7,
	"SBFTSlow":            8,
	"Hotstuff":            9,
	"Broadcast":           10,
	"Prime":               11,
	"PreDestiny":          12,
	"MinBFT":              13,
	"DuoBFT":              14,
	"MinBFTSig":           15,
	"SBFTx":               16,
	"Hybsterx":            17,
	"ChainHotstuff":       18,
	"RCC":                 19,
	"MirBFT":              20,
	"Dispel":              21,
	"DQPBFT":              22,
	"DQSBFTSlow":          23,
	"ChainDuoBFT":         24,
	"MultiChainDuoBFT":    25,
	"MultiChainDuoBFTRCC": 26,
}

func (x Algorithm) String() string {
	return proto.EnumName(Algorithm_name, int32(x))
}

func (Algorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_42a8eca82a6f6f19, []int{0}
}

// Peer related proto messages.
type BasicPeerInfo struct {
	PodName     string `protobuf:"bytes,1,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	HostMachine string `protobuf:"bytes,2,opt,name=host_machine,json=hostMachine,proto3" json:"host_machine,omitempty"`
	PodIP       string `protobuf:"bytes,3,opt,name=pod_ip,json=podIp,proto3" json:"pod_ip,omitempty"`
	Region      string `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *BasicPeerInfo) Reset()         { *m = BasicPeerInfo{} }
func (m *BasicPeerInfo) String() string { return proto.CompactTextString(m) }
func (*BasicPeerInfo) ProtoMessage()    {}
func (*BasicPeerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_42a8eca82a6f6f19, []int{0}
}
func (m *BasicPeerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicPeerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicPeerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicPeerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicPeerInfo.Merge(m, src)
}
func (m *BasicPeerInfo) XXX_Size() int {
	return m.Size()
}
func (m *BasicPeerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicPeerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BasicPeerInfo proto.InternalMessageInfo

func (m *BasicPeerInfo) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *BasicPeerInfo) GetHostMachine() string {
	if m != nil {
		return m.HostMachine
	}
	return ""
}

func (m *BasicPeerInfo) GetPodIP() string {
	if m != nil {
		return m.PodIP
	}
	return ""
}

func (m *BasicPeerInfo) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

type PeerInfo struct {
	BasicPeerInfo `protobuf:"bytes,1,opt,name=peer_info,json=peerInfo,proto3,embedded=peer_info" json:"peer_info"`
	PeerID        PeerID `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3,casttype=PeerID" json:"peer_id,omitempty"`
}

func (m *PeerInfo) Reset()         { *m = PeerInfo{} }
func (m *PeerInfo) String() string { return proto.CompactTextString(m) }
func (*PeerInfo) ProtoMessage()    {}
func (*PeerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_42a8eca82a6f6f19, []int{1}
}
func (m *PeerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerInfo.Merge(m, src)
}
func (m *PeerInfo) XXX_Size() int {
	return m.Size()
}
func (m *PeerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PeerInfo proto.InternalMessageInfo

func (m *PeerInfo) GetPeerID() PeerID {
	if m != nil {
		return m.PeerID
	}
	return 0
}

type MultiChainDuoBFTConfig struct {
	RCCMode          bool   `protobuf:"varint,1,opt,name=rcc_mode,json=rccMode,proto3" json:"rcc_mode,omitempty"`
	InstancesPerPeer uint32 `protobuf:"varint,2,opt,name=instances_per_peer,json=instancesPerPeer,proto3" json:"instances_per_peer,omitempty"`
	SkipSlowPath     bool   `protobuf:"varint,3,opt,name=skip_slow_path,json=skipSlowPath,proto3" json:"skip_slow_path,omitempty"`
}

func (m *MultiChainDuoBFTConfig) Reset()         { *m = MultiChainDuoBFTConfig{} }
func (m *MultiChainDuoBFTConfig) String() string { return proto.CompactTextString(m) }
func (*MultiChainDuoBFTConfig) ProtoMessage()    {}
func (*MultiChainDuoBFTConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_42a8eca82a6f6f19, []int{2}
}
func (m *MultiChainDuoBFTConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiChainDuoBFTConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiChainDuoBFTConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiChainDuoBFTConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiChainDuoBFTConfig.Merge(m, src)
}
func (m *MultiChainDuoBFTConfig) XXX_Size() int {
	return m.Size()
}
func (m *MultiChainDuoBFTConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiChainDuoBFTConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MultiChainDuoBFTConfig proto.InternalMessageInfo

func (m *MultiChainDuoBFTConfig) GetRCCMode() bool {
	if m != nil {
		return m.RCCMode
	}
	return false
}

func (m *MultiChainDuoBFTConfig) GetInstancesPerPeer() uint32 {
	if m != nil {
		return m.InstancesPerPeer
	}
	return 0
}

func (m *MultiChainDuoBFTConfig) GetSkipSlowPath() bool {
	if m != nil {
		return m.SkipSlowPath
	}
	return false
}

type PeerConfig struct {
	PeerDetails            []PeerInfo              `protobuf:"bytes,1,rep,name=peer_details,json=peerDetails,proto3" json:"peer_details"`
	ListenPort             int32                   `protobuf:"varint,2,opt,name=listen_port,json=listenPort,proto3" json:"listen_port,omitempty"`
	LogVerbose             bool                    `protobuf:"varint,3,opt,name=log_verbose,json=logVerbose,proto3" json:"log_verbose,omitempty"`
	Algorithm              Algorithm               `protobuf:"varint,4,opt,name=algorithm,proto3,enum=peerpb.Algorithm" json:"algorithm,omitempty"`
	MaxFailures            int32                   `protobuf:"varint,5,opt,name=max_failures,json=maxFailures,proto3" json:"max_failures,omitempty"`
	MaxFastFailures        int32                   `protobuf:"varint,6,opt,name=max_fast_failures,json=maxFastFailures,proto3" json:"max_fast_failures,omitempty"`
	LeaderID               PeerID                  `protobuf:"varint,7,opt,name=leader_id,json=leaderId,proto3,casttype=PeerID" json:"leader_id,omitempty"`
	SecretKeys             []string                `protobuf:"bytes,8,rep,name=secret_keys,json=secretKeys,proto3" json:"secret_keys,omitempty"`
	PublicKeys             []string                `protobuf:"bytes,9,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty"`
	EnclavePath            string                  `protobuf:"bytes,10,opt,name=enclave_path,json=enclavePath,proto3" json:"enclave_path,omitempty"`
	EnclaveBatchSize       int32                   `protobuf:"varint,11,opt,name=enclave_batch_size,json=enclaveBatchSize,proto3" json:"enclave_batch_size,omitempty"`
	DqOBatchSize           uint32                  `protobuf:"varint,12,opt,name=dq_o_batch_size,json=dqOBatchSize,proto3" json:"dq_o_batch_size,omitempty"`
	DqOBatchTimeout        uint32                  `protobuf:"varint,22,opt,name=dq_o_batch_timeout,json=dqOBatchTimeout,proto3" json:"dq_o_batch_timeout,omitempty"`
	Workers                map[string]uint32       `protobuf:"bytes,14,rep,name=workers,proto3" json:"workers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	WorkersQueueSizes      map[string]uint32       `protobuf:"bytes,18,rep,name=workers_queue_sizes,json=workersQueueSizes,proto3" json:"workers_queue_sizes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CmdBatchSize           uint32                  `protobuf:"varint,15,opt,name=cmd_batch_size,json=cmdBatchSize,proto3" json:"cmd_batch_size,omitempty"`
	CmdBatchTimeout        uint32                  `protobuf:"varint,16,opt,name=cmd_batch_timeout,json=cmdBatchTimeout,proto3" json:"cmd_batch_timeout,omitempty"`
	ReqBufThreshold        int32                   `protobuf:"varint,17,opt,name=req_buf_threshold,json=reqBufThreshold,proto3" json:"req_buf_threshold,omitempty"`
	ThreshsignFastLagrange bool                    `protobuf:"varint,19,opt,name=threshsign_fast_lagrange,json=threshsignFastLagrange,proto3" json:"threshsign_fast_lagrange,omitempty"`
	RccAlgorithm           Algorithm               `protobuf:"varint,20,opt,name=rcc_algorithm,json=rccAlgorithm,proto3,enum=peerpb.Algorithm" json:"rcc_algorithm,omitempty"`
	DispelWaitForAllRb     bool                    `protobuf:"varint,21,opt,name=dispel_wait_for_all_rb,json=dispelWaitForAllRb,proto3" json:"dispel_wait_for_all_rb,omitempty"`
	MultiChainDuoBFT       *MultiChainDuoBFTConfig `protobuf:"bytes,23,opt,name=multichainduobft,proto3" json:"multichainduobft,omitempty"`
}

func (m *PeerConfig) Reset()         { *m = PeerConfig{} }
func (m *PeerConfig) String() string { return proto.CompactTextString(m) }
func (*PeerConfig) ProtoMessage()    {}
func (*PeerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_42a8eca82a6f6f19, []int{3}
}
func (m *PeerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerConfig.Merge(m, src)
}
func (m *PeerConfig) XXX_Size() int {
	return m.Size()
}
func (m *PeerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PeerConfig proto.InternalMessageInfo

func (m *PeerConfig) GetPeerDetails() []PeerInfo {
	if m != nil {
		return m.PeerDetails
	}
	return nil
}

func (m *PeerConfig) GetListenPort() int32 {
	if m != nil {
		return m.ListenPort
	}
	return 0
}

func (m *PeerConfig) GetLogVerbose() bool {
	if m != nil {
		return m.LogVerbose
	}
	return false
}

func (m *PeerConfig) GetAlgorithm() Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return Algorithm_PBFT
}

func (m *PeerConfig) GetMaxFailures() int32 {
	if m != nil {
		return m.MaxFailures
	}
	return 0
}

func (m *PeerConfig) GetMaxFastFailures() int32 {
	if m != nil {
		return m.MaxFastFailures
	}
	return 0
}

func (m *PeerConfig) GetLeaderID() PeerID {
	if m != nil {
		return m.LeaderID
	}
	return 0
}

func (m *PeerConfig) GetSecretKeys() []string {
	if m != nil {
		return m.SecretKeys
	}
	return nil
}

func (m *PeerConfig) GetPublicKeys() []string {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *PeerConfig) GetEnclavePath() string {
	if m != nil {
		return m.EnclavePath
	}
	return ""
}

func (m *PeerConfig) GetEnclaveBatchSize() int32 {
	if m != nil {
		return m.EnclaveBatchSize
	}
	return 0
}

func (m *PeerConfig) GetDqOBatchSize() uint32 {
	if m != nil {
		return m.DqOBatchSize
	}
	return 0
}

func (m *PeerConfig) GetDqOBatchTimeout() uint32 {
	if m != nil {
		return m.DqOBatchTimeout
	}
	return 0
}

func (m *PeerConfig) GetWorkers() map[string]uint32 {
	if m != nil {
		return m.Workers
	}
	return nil
}

func (m *PeerConfig) GetWorkersQueueSizes() map[string]uint32 {
	if m != nil {
		return m.WorkersQueueSizes
	}
	return nil
}

func (m *PeerConfig) GetCmdBatchSize() uint32 {
	if m != nil {
		return m.CmdBatchSize
	}
	return 0
}

func (m *PeerConfig) GetCmdBatchTimeout() uint32 {
	if m != nil {
		return m.CmdBatchTimeout
	}
	return 0
}

func (m *PeerConfig) GetReqBufThreshold() int32 {
	if m != nil {
		return m.ReqBufThreshold
	}
	return 0
}

func (m *PeerConfig) GetThreshsignFastLagrange() bool {
	if m != nil {
		return m.ThreshsignFastLagrange
	}
	return false
}

func (m *PeerConfig) GetRccAlgorithm() Algorithm {
	if m != nil {
		return m.RccAlgorithm
	}
	return Algorithm_PBFT
}

func (m *PeerConfig) GetDispelWaitForAllRb() bool {
	if m != nil {
		return m.DispelWaitForAllRb
	}
	return false
}

func (m *PeerConfig) GetMultiChainDuoBFT() *MultiChainDuoBFTConfig {
	if m != nil {
		return m.MultiChainDuoBFT
	}
	return nil
}

type Message struct {
	From        PeerID            `protobuf:"varint,1,opt,name=from,proto3,casttype=PeerID" json:"from,omitempty"`
	To          PeerID            `protobuf:"varint,2,opt,name=to,proto3,casttype=PeerID" json:"to,omitempty"`
	Content     []byte            `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Certificate []byte            `protobuf:"bytes,4,opt,name=certificate,proto3" json:"certificate,omitempty"`
	TraceInfo   map[string]string `protobuf:"bytes,5,rep,name=trace_info,json=traceInfo,proto3" json:"trace_info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_42a8eca82a6f6f19, []int{4}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetFrom() PeerID {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Message) GetTo() PeerID {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Message) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Message) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *Message) GetTraceInfo() map[string]string {
	if m != nil {
		return m.TraceInfo
	}
	return nil
}

func init() {
	proto.RegisterEnum("peerpb.Algorithm", Algorithm_name, Algorithm_value)
	proto.RegisterType((*BasicPeerInfo)(nil), "peerpb.BasicPeerInfo")
	proto.RegisterType((*PeerInfo)(nil), "peerpb.PeerInfo")
	proto.RegisterType((*MultiChainDuoBFTConfig)(nil), "peerpb.MultiChainDuoBFTConfig")
	proto.RegisterType((*PeerConfig)(nil), "peerpb.PeerConfig")
	proto.RegisterMapType((map[string]uint32)(nil), "peerpb.PeerConfig.WorkersEntry")
	proto.RegisterMapType((map[string]uint32)(nil), "peerpb.PeerConfig.WorkersQueueSizesEntry")
	proto.RegisterType((*Message)(nil), "peerpb.Message")
	proto.RegisterMapType((map[string]string)(nil), "peerpb.Message.TraceInfoEntry")
}

func init() { proto.RegisterFile("peer/peerpb/peer.proto", fileDescriptor_42a8eca82a6f6f19) }

var fileDescriptor_42a8eca82a6f6f19 = []byte{
	// 1289 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4b, 0x6f, 0xdb, 0xc6,
	0x16, 0xb6, 0xac, 0x27, 0x8f, 0x64, 0x9b, 0x1a, 0x3b, 0x0a, 0xe3, 0x85, 0xe4, 0x18, 0xf7, 0x5e,
	0xe4, 0xfa, 0xde, 0xd8, 0x81, 0x03, 0x14, 0x49, 0x90, 0x2e, 0x22, 0x39, 0x46, 0x8c, 0xda, 0xad,
	0x42, 0x1b, 0x0d, 0x1a, 0xa0, 0x60, 0x47, 0xe4, 0x48, 0x1a, 0x98, 0xe4, 0xd0, 0x33, 0x23, 0xcb,
	0xf2, 0xb6, 0x8b, 0x6e, 0xbb, 0xe8, 0x3f, 0xea, 0x26, 0xcb, 0x2c, 0xbb, 0x32, 0x0a, 0xe5, 0x5f,
	0x74, 0x51, 0x14, 0x33, 0x43, 0x4a, 0xca, 0x0b, 0x45, 0x37, 0xd2, 0xcc, 0x77, 0xbe, 0x39, 0xaf,
	0xf9, 0x78, 0x48, 0x68, 0x24, 0x84, 0xf0, 0x3d, 0xf5, 0x93, 0xf4, 0xf4, 0xdf, 0x6e, 0xc2, 0x99,
	0x64, 0xa8, 0x64, 0xa0, 0xcd, 0x8d, 0x01, 0x1b, 0x30, 0x0d, 0xed, 0xa9, 0x95, 0xb1, 0x6e, 0xff,
	0x94, 0x83, 0x95, 0x36, 0x16, 0xd4, 0xef, 0x12, 0xc2, 0x8f, 0xe2, 0x3e, 0x43, 0x77, 0xa0, 0x92,
	0xb0, 0xc0, 0x8b, 0x71, 0x44, 0x9c, 0xdc, 0x56, 0xee, 0x9e, 0xe5, 0x96, 0x13, 0x16, 0x7c, 0x8d,
	0x23, 0x82, 0xee, 0x42, 0x6d, 0xc8, 0x84, 0xf4, 0x22, 0xec, 0x0f, 0x69, 0x4c, 0x9c, 0x65, 0x6d,
	0xae, 0x2a, 0xec, 0xc4, 0x40, 0x68, 0x0b, 0x4a, 0xea, 0x34, 0x4d, 0x9c, 0xbc, 0x32, 0xb6, 0xad,
	0xe9, 0x4d, 0xab, 0xd8, 0x65, 0xc1, 0x51, 0xd7, 0x2d, 0x26, 0x2c, 0x38, 0x4a, 0x50, 0x03, 0x4a,
	0x9c, 0x0c, 0x28, 0x8b, 0x9d, 0x82, 0x3e, 0x9e, 0xee, 0xb6, 0xc7, 0x50, 0x99, 0xe5, 0xf0, 0x14,
	0x2c, 0x95, 0xb5, 0x47, 0xe3, 0x3e, 0xd3, 0x49, 0x54, 0xf7, 0x6f, 0xed, 0x9a, 0x3a, 0x76, 0xdf,
	0xcb, 0xb6, 0x5d, 0x79, 0x73, 0xd3, 0x5a, 0x7a, 0x7b, 0xd3, 0xca, 0xb9, 0x95, 0x24, 0x3b, 0x7d,
	0x1f, 0xca, 0xe6, 0x74, 0xa0, 0x33, 0x2c, 0xb4, 0x37, 0xa6, 0x37, 0xad, 0x92, 0x3e, 0x72, 0xf0,
	0xc7, 0x6c, 0xe5, 0xea, 0xc6, 0x1c, 0x05, 0xdb, 0xbf, 0xe4, 0xa0, 0x71, 0x32, 0x0a, 0x25, 0xed,
	0x0c, 0x31, 0x8d, 0x0f, 0x46, 0xac, 0x7d, 0x78, 0xd6, 0x61, 0x71, 0x9f, 0x0e, 0xd0, 0x7f, 0xa0,
	0xc2, 0x7d, 0xdf, 0x8b, 0x58, 0x60, 0x7a, 0x51, 0x69, 0x57, 0xa7, 0x37, 0xad, 0xb2, 0xdb, 0xe9,
	0x9c, 0xb0, 0x80, 0xb8, 0x65, 0xee, 0xfb, 0x6a, 0x81, 0xfe, 0x0f, 0x88, 0xc6, 0x42, 0xe2, 0xd8,
	0x27, 0xc2, 0x4b, 0x08, 0xf7, 0x94, 0x6b, 0x1d, 0x7c, 0xc5, 0xb5, 0x67, 0x96, 0x2e, 0xe1, 0x2a,
	0x34, 0xfa, 0x17, 0xac, 0x8a, 0x73, 0x9a, 0x78, 0x22, 0x64, 0x63, 0x2f, 0xc1, 0x72, 0xa8, 0x7b,
	0x55, 0x71, 0x6b, 0x0a, 0x3d, 0x0d, 0xd9, 0xb8, 0x8b, 0xe5, 0x70, 0xfb, 0x57, 0x0b, 0x40, 0xd1,
	0xd3, 0x54, 0x1e, 0x43, 0x4d, 0x17, 0x15, 0x10, 0x89, 0x69, 0x28, 0x9c, 0xdc, 0x56, 0xfe, 0x5e,
	0x75, 0xdf, 0xce, 0xba, 0x32, 0x6b, 0x48, 0x41, 0x35, 0xc4, 0xad, 0x2a, 0xf8, 0xc0, 0x50, 0x51,
	0x0b, 0xaa, 0x21, 0x15, 0x92, 0xc4, 0x5e, 0xc2, 0xb8, 0xd4, 0x69, 0x15, 0x5d, 0x30, 0x50, 0x97,
	0x71, 0xa9, 0x09, 0x6c, 0xe0, 0x5d, 0x12, 0xde, 0x63, 0x82, 0xa4, 0xd9, 0x40, 0xc8, 0x06, 0xdf,
	0x1a, 0x04, 0xed, 0x81, 0x85, 0xc3, 0x01, 0xe3, 0x54, 0x0e, 0x23, 0x7d, 0x6d, 0xab, 0xfb, 0xf5,
	0x2c, 0xf2, 0xb3, 0xcc, 0xe0, 0xce, 0x39, 0x4a, 0x29, 0x11, 0xbe, 0xf2, 0xfa, 0x98, 0x86, 0x23,
	0x4e, 0x84, 0x53, 0xd4, 0x31, 0xab, 0x11, 0xbe, 0x3a, 0x4c, 0x21, 0xb4, 0x03, 0x75, 0x43, 0x11,
	0x72, 0xce, 0x2b, 0x69, 0xde, 0x9a, 0xe6, 0x09, 0x39, 0xe3, 0x3e, 0x04, 0x2b, 0x24, 0x38, 0x30,
	0x77, 0x5a, 0xd6, 0x77, 0xda, 0x98, 0xde, 0xb4, 0x2a, 0xc7, 0x1a, 0x7c, 0xef, 0x56, 0x2b, 0x86,
	0x78, 0x14, 0xa8, 0xaa, 0x04, 0xf1, 0x39, 0x91, 0xde, 0x39, 0x99, 0x08, 0xa7, 0xb2, 0x95, 0xbf,
	0x67, 0xb9, 0x60, 0xa0, 0xaf, 0xc8, 0x44, 0xf7, 0x25, 0x19, 0xf5, 0x42, 0xea, 0x1b, 0x82, 0x65,
	0x08, 0x06, 0xd2, 0x84, 0xbb, 0x50, 0x23, 0xb1, 0x1f, 0xe2, 0x4b, 0x62, 0xae, 0x09, 0x8c, 0xde,
	0x53, 0x4c, 0xdd, 0x92, 0xba, 0xf9, 0x8c, 0xd2, 0xc3, 0xd2, 0x1f, 0x7a, 0x82, 0x5e, 0x13, 0xa7,
	0xaa, 0xcb, 0xb0, 0x53, 0x4b, 0x5b, 0x19, 0x4e, 0xe9, 0x35, 0x41, 0xff, 0x86, 0xb5, 0xe0, 0xc2,
	0x63, 0x8b, 0xd4, 0x9a, 0x16, 0x49, 0x2d, 0xb8, 0xf8, 0x66, 0x4e, 0xfb, 0x1f, 0xa0, 0x05, 0x9a,
	0xa4, 0x11, 0x61, 0x23, 0xe9, 0x34, 0x34, 0x73, 0x2d, 0x63, 0x9e, 0x19, 0x18, 0x3d, 0x86, 0xf2,
	0x98, 0xf1, 0x73, 0xc2, 0x85, 0xb3, 0xaa, 0x35, 0xd1, 0x5a, 0xd4, 0x84, 0x51, 0xcf, 0xee, 0x2b,
	0xc3, 0x78, 0x1e, 0x4b, 0x3e, 0x71, 0x33, 0x3e, 0xfa, 0x0e, 0xd6, 0xd3, 0xa5, 0x77, 0x31, 0x22,
	0x23, 0xa2, 0x33, 0x12, 0x0e, 0xd2, 0x6e, 0xfe, 0xfb, 0x79, 0x37, 0x2f, 0x15, 0x59, 0x65, 0x9a,
	0x3a, 0xac, 0x8f, 0x3f, 0xc4, 0x95, 0xc6, 0xfd, 0x28, 0x58, 0x2c, 0x74, 0xcd, 0x14, 0xea, 0x47,
	0xc1, 0xbc, 0xd0, 0x1d, 0xa8, 0xcf, 0x59, 0x59, 0x9d, 0xb6, 0xa9, 0x33, 0x23, 0x66, 0x75, 0xee,
	0x40, 0x9d, 0x93, 0x0b, 0xaf, 0x37, 0xea, 0x7b, 0x72, 0xc8, 0x89, 0x18, 0xb2, 0x30, 0x70, 0xea,
	0x46, 0x2f, 0x9c, 0x5c, 0xb4, 0x47, 0xfd, 0xb3, 0x0c, 0x46, 0x8f, 0xc0, 0x31, 0x1c, 0x41, 0x07,
	0xb1, 0x91, 0x58, 0x88, 0x07, 0x1c, 0xc7, 0x03, 0xe2, 0xac, 0x6b, 0x75, 0x37, 0xe6, 0x76, 0xa5,
	0xb4, 0xe3, 0xd4, 0x8a, 0xbe, 0x80, 0x15, 0xf5, 0xc4, 0xcf, 0xd5, 0xbe, 0xf1, 0x39, 0xb5, 0xd7,
	0xb8, 0xef, 0xcf, 0x76, 0x68, 0x1f, 0x1a, 0x01, 0x15, 0x09, 0x09, 0xbd, 0x31, 0xa6, 0xd2, 0xeb,
	0x33, 0xee, 0xe1, 0x30, 0xf4, 0x78, 0xcf, 0xb9, 0xa5, 0xe3, 0x21, 0x63, 0x7d, 0x85, 0xa9, 0x3c,
	0x64, 0xfc, 0x59, 0x18, 0xba, 0x3d, 0xf4, 0x03, 0xd8, 0x91, 0x9a, 0x3b, 0xbe, 0x9a, 0x3b, 0xc1,
	0x88, 0xf5, 0xfa, 0xd2, 0xb9, 0xad, 0x87, 0x5d, 0x33, 0x0b, 0xf7, 0xe9, 0xb9, 0xa4, 0x07, 0x9a,
	0xfd, 0xa1, 0xcd, 0xfd, 0xc8, 0xdb, 0xe6, 0x13, 0xa8, 0x2d, 0xde, 0x3c, 0xb2, 0x21, 0x7f, 0x4e,
	0x26, 0xe9, 0x58, 0x57, 0x4b, 0xb4, 0x01, 0xc5, 0x4b, 0x1c, 0x8e, 0x48, 0x3a, 0xac, 0xcc, 0xe6,
	0xc9, 0xf2, 0xa3, 0xdc, 0xe6, 0x01, 0x34, 0x3e, 0x7d, 0xdd, 0xff, 0xc4, 0xcb, 0xf6, 0x9f, 0x39,
	0x28, 0x9f, 0x10, 0x21, 0xf0, 0x80, 0xa0, 0x26, 0x14, 0xfa, 0x9c, 0x45, 0xfa, 0x60, 0xa1, 0x0d,
	0x0b, 0x0f, 0xad, 0xc6, 0xd1, 0x26, 0x2c, 0x4b, 0x96, 0x8e, 0xec, 0x45, 0xeb, 0xb2, 0x64, 0xc8,
	0x81, 0xb2, 0xcf, 0x62, 0x49, 0x62, 0xa9, 0xc7, 0x53, 0xcd, 0xcd, 0xb6, 0x68, 0x0b, 0xaa, 0x3e,
	0xe1, 0x92, 0xf6, 0xa9, 0x8f, 0x25, 0xd1, 0xd3, 0xa9, 0xe6, 0x2e, 0x42, 0xe8, 0x4b, 0x00, 0xc9,
	0xb1, 0x4f, 0xcc, 0xeb, 0xa4, 0xa8, 0xd5, 0x3d, 0xef, 0xb0, 0x49, 0x6e, 0xf7, 0x4c, 0x31, 0xd4,
	0x04, 0x35, 0x92, 0xb6, 0x64, 0xb6, 0xdf, 0x7c, 0x0a, 0xab, 0xef, 0x1b, 0xff, 0xae, 0x01, 0xd6,
	0x42, 0x03, 0x76, 0x7e, 0xcc, 0x83, 0x35, 0x97, 0x49, 0x05, 0x0a, 0xdd, 0xf6, 0xe1, 0x99, 0xbd,
	0xa4, 0x56, 0xa7, 0x6a, 0x95, 0x43, 0x55, 0x28, 0xbf, 0x9e, 0x5c, 0x5f, 0x4f, 0x2e, 0xb1, 0xbd,
	0x8c, 0x2c, 0x28, 0x3e, 0xbf, 0x56, 0x78, 0x5e, 0xe1, 0x2f, 0x26, 0x3d, 0x21, 0x09, 0xb7, 0x0b,
	0x6a, 0x73, 0x40, 0x84, 0xa4, 0xf1, 0xc4, 0x2e, 0x22, 0x80, 0x92, 0xda, 0x10, 0x6e, 0x97, 0xd0,
	0x2a, 0xc0, 0x31, 0x8d, 0x33, 0x62, 0x19, 0xd5, 0xa0, 0xa2, 0xfc, 0xaa, 0xd7, 0x88, 0x5d, 0x51,
	0xbb, 0x17, 0x4c, 0x0a, 0x39, 0xea, 0xf7, 0x6d, 0x0b, 0xad, 0x80, 0xd5, 0xe6, 0x0c, 0x07, 0x3e,
	0x16, 0xd2, 0x06, 0x15, 0xab, 0xcb, 0x69, 0x44, 0xec, 0xaa, 0xf2, 0xd2, 0xe5, 0x24, 0x8b, 0x50,
	0x53, 0x11, 0x4e, 0x68, 0xac, 0xf2, 0x58, 0xd1, 0xd1, 0xb4, 0xc0, 0xec, 0x55, 0xe5, 0xc1, 0xe0,
	0xa7, 0x74, 0x60, 0xaf, 0x29, 0x0f, 0x2a, 0xd8, 0x95, 0x6d, 0xeb, 0x48, 0x26, 0x89, 0x2b, 0xbb,
	0x8e, 0xea, 0xb0, 0xa2, 0x95, 0x39, 0x0b, 0x8e, 0x50, 0x19, 0xf2, 0x6e, 0xa7, 0x63, 0xaf, 0x1b,
	0xdf, 0x5c, 0xf9, 0xdb, 0xd0, 0xbe, 0xf5, 0x83, 0x61, 0xdf, 0xd2, 0xeb, 0x97, 0xba, 0x3b, 0x0d,
	0x95, 0xcf, 0xc1, 0xcb, 0x59, 0x1d, 0xb7, 0xd1, 0x1a, 0x54, 0x17, 0x94, 0x6e, 0x3b, 0x68, 0x03,
	0x3e, 0xd2, 0xbf, 0x7d, 0x07, 0xdd, 0x86, 0xf5, 0x8f, 0x9e, 0x8a, 0x4e, 0xc7, 0xde, 0x6c, 0x7f,
	0xff, 0x66, 0xda, 0xcc, 0xbd, 0x9d, 0x36, 0x73, 0xbf, 0x4f, 0x9b, 0xb9, 0x9f, 0xdf, 0x35, 0x97,
	0xde, 0xbe, 0x6b, 0x2e, 0xfd, 0xf6, 0xae, 0xb9, 0xf4, 0xba, 0x33, 0xa0, 0x72, 0x38, 0xea, 0xed,
	0xfa, 0x2c, 0xda, 0x8b, 0xa9, 0x1c, 0xd2, 0xf8, 0x1c, 0xcb, 0x10, 0x3f, 0x78, 0xb0, 0xe7, 0x1e,
	0xdf, 0xd7, 0xce, 0xcc, 0x4b, 0xa6, 0xab, 0x3e, 0x97, 0x7c, 0x16, 0x9e, 0x8e, 0xa9, 0xf4, 0x87,
	0xe9, 0x97, 0x56, 0xfa, 0xb9, 0xd5, 0x2b, 0xe9, 0x8f, 0xa9, 0x87, 0x7f, 0x05, 0x00, 0x00, 0xff,
	0xff, 0x81, 0xcc, 0xcd, 0x77, 0x84, 0x09, 0x00, 0x00,
}

func (m *BasicPeerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicPeerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasicPeerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PodIP) > 0 {
		i -= len(m.PodIP)
		copy(dAtA[i:], m.PodIP)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.PodIP)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostMachine) > 0 {
		i -= len(m.HostMachine)
		copy(dAtA[i:], m.HostMachine)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.HostMachine)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodName) > 0 {
		i -= len(m.PodName)
		copy(dAtA[i:], m.PodName)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.PodName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeerID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.PeerID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.BasicPeerInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPeer(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MultiChainDuoBFTConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiChainDuoBFTConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiChainDuoBFTConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipSlowPath {
		i--
		if m.SkipSlowPath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.InstancesPerPeer != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.InstancesPerPeer))
		i--
		dAtA[i] = 0x10
	}
	if m.RCCMode {
		i--
		if m.RCCMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MultiChainDuoBFT != nil {
		{
			size, err := m.MultiChainDuoBFT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.DqOBatchTimeout != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.DqOBatchTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.DispelWaitForAllRb {
		i--
		if m.DispelWaitForAllRb {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RccAlgorithm != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.RccAlgorithm))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ThreshsignFastLagrange {
		i--
		if m.ThreshsignFastLagrange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.WorkersQueueSizes) > 0 {
		for k := range m.WorkersQueueSizes {
			v := m.WorkersQueueSizes[k]
			baseI := i
			i = encodeVarintPeer(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPeer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPeer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.ReqBufThreshold != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.ReqBufThreshold))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.CmdBatchTimeout != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.CmdBatchTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CmdBatchSize != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.CmdBatchSize))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Workers) > 0 {
		for k := range m.Workers {
			v := m.Workers[k]
			baseI := i
			i = encodeVarintPeer(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPeer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPeer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.DqOBatchSize != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.DqOBatchSize))
		i--
		dAtA[i] = 0x60
	}
	if m.EnclaveBatchSize != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.EnclaveBatchSize))
		i--
		dAtA[i] = 0x58
	}
	if len(m.EnclavePath) > 0 {
		i -= len(m.EnclavePath)
		copy(dAtA[i:], m.EnclavePath)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.EnclavePath)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PublicKeys) > 0 {
		for iNdEx := len(m.PublicKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PublicKeys[iNdEx])
			copy(dAtA[i:], m.PublicKeys[iNdEx])
			i = encodeVarintPeer(dAtA, i, uint64(len(m.PublicKeys[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.SecretKeys) > 0 {
		for iNdEx := len(m.SecretKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SecretKeys[iNdEx])
			copy(dAtA[i:], m.SecretKeys[iNdEx])
			i = encodeVarintPeer(dAtA, i, uint64(len(m.SecretKeys[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.LeaderID != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.LeaderID))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxFastFailures != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MaxFastFailures))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxFailures != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.MaxFailures))
		i--
		dAtA[i] = 0x28
	}
	if m.Algorithm != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x20
	}
	if m.LogVerbose {
		i--
		if m.LogVerbose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ListenPort != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.ListenPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PeerDetails) > 0 {
		for iNdEx := len(m.PeerDetails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PeerDetails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPeer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TraceInfo) > 0 {
		for k := range m.TraceInfo {
			v := m.TraceInfo[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPeer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPeer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPeer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if m.To != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPeer(dAtA []byte, offset int, v uint64) int {
	offset -= sovPeer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BasicPeerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.HostMachine)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.PodIP)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *PeerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BasicPeerInfo.Size()
	n += 1 + l + sovPeer(uint64(l))
	if m.PeerID != 0 {
		n += 1 + sovPeer(uint64(m.PeerID))
	}
	return n
}

func (m *MultiChainDuoBFTConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RCCMode {
		n += 2
	}
	if m.InstancesPerPeer != 0 {
		n += 1 + sovPeer(uint64(m.InstancesPerPeer))
	}
	if m.SkipSlowPath {
		n += 2
	}
	return n
}

func (m *PeerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PeerDetails) > 0 {
		for _, e := range m.PeerDetails {
			l = e.Size()
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	if m.ListenPort != 0 {
		n += 1 + sovPeer(uint64(m.ListenPort))
	}
	if m.LogVerbose {
		n += 2
	}
	if m.Algorithm != 0 {
		n += 1 + sovPeer(uint64(m.Algorithm))
	}
	if m.MaxFailures != 0 {
		n += 1 + sovPeer(uint64(m.MaxFailures))
	}
	if m.MaxFastFailures != 0 {
		n += 1 + sovPeer(uint64(m.MaxFastFailures))
	}
	if m.LeaderID != 0 {
		n += 1 + sovPeer(uint64(m.LeaderID))
	}
	if len(m.SecretKeys) > 0 {
		for _, s := range m.SecretKeys {
			l = len(s)
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	if len(m.PublicKeys) > 0 {
		for _, s := range m.PublicKeys {
			l = len(s)
			n += 1 + l + sovPeer(uint64(l))
		}
	}
	l = len(m.EnclavePath)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.EnclaveBatchSize != 0 {
		n += 1 + sovPeer(uint64(m.EnclaveBatchSize))
	}
	if m.DqOBatchSize != 0 {
		n += 1 + sovPeer(uint64(m.DqOBatchSize))
	}
	if len(m.Workers) > 0 {
		for k, v := range m.Workers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPeer(uint64(len(k))) + 1 + sovPeer(uint64(v))
			n += mapEntrySize + 1 + sovPeer(uint64(mapEntrySize))
		}
	}
	if m.CmdBatchSize != 0 {
		n += 1 + sovPeer(uint64(m.CmdBatchSize))
	}
	if m.CmdBatchTimeout != 0 {
		n += 2 + sovPeer(uint64(m.CmdBatchTimeout))
	}
	if m.ReqBufThreshold != 0 {
		n += 2 + sovPeer(uint64(m.ReqBufThreshold))
	}
	if len(m.WorkersQueueSizes) > 0 {
		for k, v := range m.WorkersQueueSizes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPeer(uint64(len(k))) + 1 + sovPeer(uint64(v))
			n += mapEntrySize + 2 + sovPeer(uint64(mapEntrySize))
		}
	}
	if m.ThreshsignFastLagrange {
		n += 3
	}
	if m.RccAlgorithm != 0 {
		n += 2 + sovPeer(uint64(m.RccAlgorithm))
	}
	if m.DispelWaitForAllRb {
		n += 3
	}
	if m.DqOBatchTimeout != 0 {
		n += 2 + sovPeer(uint64(m.DqOBatchTimeout))
	}
	if m.MultiChainDuoBFT != nil {
		l = m.MultiChainDuoBFT.Size()
		n += 2 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovPeer(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovPeer(uint64(m.To))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if len(m.TraceInfo) > 0 {
		for k, v := range m.TraceInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPeer(uint64(len(k))) + 1 + len(v) + sovPeer(uint64(len(v)))
			n += mapEntrySize + 1 + sovPeer(uint64(mapEntrySize))
		}
	}
	return n
}

func sovPeer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPeer(x uint64) (n int) {
	return sovPeer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BasicPeerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicPeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicPeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostMachine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostMachine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicPeerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BasicPeerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= PeerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiChainDuoBFTConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiChainDuoBFTConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiChainDuoBFTConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RCCMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RCCMode = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstancesPerPeer", wireType)
			}
			m.InstancesPerPeer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstancesPerPeer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipSlowPath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipSlowPath = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerDetails = append(m.PeerDetails, PeerInfo{})
			if err := m.PeerDetails[len(m.PeerDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenPort", wireType)
			}
			m.ListenPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListenPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogVerbose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogVerbose = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= Algorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFailures", wireType)
			}
			m.MaxFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFailures |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFastFailures", wireType)
			}
			m.MaxFastFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFastFailures |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			m.LeaderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderID |= PeerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKeys = append(m.SecretKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclavePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnclavePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclaveBatchSize", wireType)
			}
			m.EnclaveBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnclaveBatchSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DqOBatchSize", wireType)
			}
			m.DqOBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DqOBatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Workers == nil {
				m.Workers = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPeer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPeer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPeer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPeer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPeer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPeer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPeer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Workers[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdBatchSize", wireType)
			}
			m.CmdBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdBatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdBatchTimeout", wireType)
			}
			m.CmdBatchTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdBatchTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBufThreshold", wireType)
			}
			m.ReqBufThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqBufThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkersQueueSizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkersQueueSizes == nil {
				m.WorkersQueueSizes = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPeer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPeer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPeer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPeer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPeer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPeer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPeer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WorkersQueueSizes[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreshsignFastLagrange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ThreshsignFastLagrange = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RccAlgorithm", wireType)
			}
			m.RccAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RccAlgorithm |= Algorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DispelWaitForAllRb", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DispelWaitForAllRb = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DqOBatchTimeout", wireType)
			}
			m.DqOBatchTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DqOBatchTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiChainDuoBFT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiChainDuoBFT == nil {
				m.MultiChainDuoBFT = &MultiChainDuoBFTConfig{}
			}
			if err := m.MultiChainDuoBFT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= PeerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= PeerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate[:0], dAtA[iNdEx:postIndex]...)
			if m.Certificate == nil {
				m.Certificate = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TraceInfo == nil {
				m.TraceInfo = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPeer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPeer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPeer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPeer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPeer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPeer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPeer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPeer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPeer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TraceInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPeer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPeer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPeer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPeer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPeer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPeer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPeer = fmt.Errorf("proto: unexpected end of group")
)
